"""
RUN USING PYTHON3
PYTHON MODULE TO PLOT QUANTITIES TO STUDY IN MASTER THESIS 
"""
import dis
import re
import sys, os
import numpy as np
import pynbody
import matplotlib.pyplot as plt
import h5py
from scipy.__config__ import show
# from functions import *
from params import *
import matplotlib.gridspec as gridspec
import pandas as pd

def species_dictionary(file = './info.dat'):
	""" From the info.dat file generated by KROME creates a dictionary of the species
	with their KROME names as the key, and 2 assigned values: their indexes in accord
	to the info.log file, and their masses [g] """
	f = open(file, 'r')
	lines = f.readlines()
	species = []
	indexes = []
	masses  = []
	for x in lines[:-4]:
		species.append(str(x.split('\t')[0]))
		indexes.append(int(x.split('\t')[1]))
		masses.append(float(x.split('\t')[2]))
	f.close()
	dict_indexs = dict(zip(species, indexes))
	dict_masses = dict(zip(species, masses))
	return dict_indexs, dict_masses

def SIGMA(r,rc,Sigma_c,gamma):
	"""Radial profile calculation function

	Args:
		r (int): _description_
		rc (int): _description_
		Sigma_c (int): _description_
		gamma (int): _description_

	Returns:
		Sigma (int): Radial distribution
	"""
	y = Sigma_c*(r/rc)**(-gamma)*np.exp(-(r/rc)**(2-gamma))
	return y

def load_data(fname):
	"""Data loading from specified fname

	Args:
		fname (str): Data file name.

	Returns:
		sim (GadgetHDFSnap): Simulation data.
	"""
	sim = pynbody.load(fname)
	if ".hdf5" in fname: sim.properties["boxsize"] = sim.properties["boxsize"][0]
	return sim

def process_data(sim,recenter=None):
	"""Data process, this includes all necessary values and parameters to the data.
	
	Args:
		sim (GadgetHDFSnap): Simulation extracted data.
		recenter (list): If specified recenters the simulation in the given
						 coordinates as [x,y] (default None)

	Returns:
		sim (GadgetHDFSnap): Processed simulation data.
	"""
	gamma=7./5.
	mH=1.67e-24*pynbody.units.g # g
	mu=2.38
	kB=1.38069e-16*pynbody.units.Unit("cm^2 g s^-2 K^-1") # cm**2 g s**-2 K**-1
	kSB = 5.6704e-5*pynbody.units.Unit("erg cm^-2 s^-1 K^-4")
	conversion=((gamma-1)*mH*mu)/kB

	species, masses = species_dictionary()

	derivation = ((pynbody.units.G*pynbody.units.Unit("Msol")/pynbody.units.Unit("0.1 pc"))**(1,2)).in_units("cm s^-1")

	sim.set_units_system(
		velocity = f"{derivation} cm s^-1", 
		mass = "Msol",
		temperature = "K", 
		distance = "0.1 pc"
		)
	
	sim.g["rho"].convert_units("g cm^-3")
	sim.g["u"].convert_units("cm^2 s^-2")

	## Rescale smoothing length to match Gasoline's definition of kernel extending up to 2*h
	sim.g["smooth"] /= 2 # DEF: 2
	sim.g["ntot"] = pynbody.array.SimArray(sim.g["rho"], "g cm^-3")/mH/mu # TOTAL DENSITY DEFINITION
	sim.g["temp"] = (pynbody.array.SimArray(sim.g["u"], "cm^2 s^-2")*conversion).in_units('K')

	try:sim.g["RadEnergy"].units = pynbody.units.Unit("K") # Is this radiant energy or just radiant temperature
	except:print("Data does not contain <RadEnergy>")
	try:sim.g["RadTemp"] = sim.g["RadEnergy"].in_units("K") # Lets assume it's temperature
	except:print("Data does not contain <RadTemp>")
	try:
		sim.g["Av"] = -np.log(pynbody.array.SimArray(sim.g["Extinction"]))
		sim.g['Av'] = np.where(np.isfinite(sim.g['Av']),sim.g['Av'],1e3) # mask inf values
	except:print("Data does not contain <Extinction>")
	try:sim.g["flux"] = (kSB * (pynbody.array.SimArray(sim.g["RadTemp"], "K")**4)).in_units("erg s^-1 cm^-2") # S-Bs Law
	except:print("Data does not contain <Flux>")

	if recenter is not None:
		sim["x"] -= recenter[0]
		sim["y"] -= recenter[1]
		sim["z"] -= np.average(sim.g["z"],weights = sim.g["ntot"])
	else:
		sim["x"] -= np.average(sim.g["x"], weights = sim.g["ntot"])
		sim["y"] -= np.average(sim.g["y"], weights = sim.g["ntot"])
		sim["z"] -= np.average(sim.g["z"], weights = sim.g["ntot"])

	if "KromeSpecies" in sim.g.loadable_keys():
		for i in species:
			j = species[i] - 1
			sim.g[i] = pynbody.array.SimArray(sim.g["KromeSpecies"][:, j]*sim.g["rho"]/masses[i], "cm^-3")
				
		for specie in species:
			if "_" not in specie:
				continue
			elif "META" in specie or "ANTA" in specie or "DUST" in specie or "GRAIN" in specie or "NH2D2+" in specie:
				continue				
			else:
				common_part = specie.split("_")[0]
				sim.g[common_part] = (sim.g[f"{common_part}_ORTHO"]+sim.g[f"{common_part}_PARA"])

	return sim

def eccentricity(sink_data, particle_data):
	"""Eccentricity calculation function

	Args:
		m1 (int): Object 1 mass (in grams)
		m2 (int): Object 2 mass (in grams)
		v (int): Relative velocity from object 1 to object 2(in cm/s)
		r (int): Relative distance from object 1 to object 2 (in cm)
		V (int): Relative velocity vector from object 1 to object 2 (in cm/s)
		R (int): Relative distance vector from object 1 to object 2 (in cm)

	Returns:
		int: Orbital eccentricity for the selected particle
	"""
	sink_mass = sink_data['mass'].in_units('g')
	particle_mass = particle_data['mass'].in_units('g')
	relative_V = particle_data['vel'].in_units('cm s^-1') - sink_data['vel'].in_units('cm s^-1')
	relative_v = (relative_V[:,0]**2 + relative_V[:,1]**2 + relative_V[:,2]**2)**0.5
	relative_R = particle_data['pos'].in_units('cm') - sink_data['pos'].in_units('cm')
	relative_r = (relative_R[:,0]**2 + relative_R[:,1]**2 + relative_R[:,2]**2)**0.5
	
	h = np.cross(relative_R,relative_V)
	mu_std = G * (sink_mass + particle_mass)
	mu_std = mu_std[0] # all the values are the same so I fixed them to just one value
	h_mu = h/mu_std # fix to avoid infinite values befor dividing by mu_std
	h_mu = (h_mu[:,0]**2 + h_mu[:,1]**2 + h_mu[:,2]**2)**0.5
	eps = relative_v**2 / 2 - mu_std / relative_r
	e = (1 + (2 * eps * h_mu**2))**0.5
	return e

def disk_characterization(sim):
	sink = sim.bh[0]
	sim['pos'] -= sink['pos']
	sphere = sim[pynbody.filt.Sphere(radius="2000 au",cen=np.zeros(3))]
	particles = sphere.g[:]
	sphere.g['e'] = pynbody.array.SimArray(eccentricity(sink_data = sink, particle_data = particles))
	disk = sphere.g[pynbody.filt.LowPass('e',0.3)]
	print(disk)
	pynbody.plot.sph.image(disk,qty="rho",width="200 au",cmap="viridis",units="g cm^-2",noplot=False)
	plt.show()

def main(fname):
	"""
	Main function to execute the plotting process.	
	
	Parameters:
		fname (str): The name of the data file.
	"""
	try:
		snapshot_num = fname.split('/')[-1].split('_')[1]

		# Load data
		sim = load_data(fname)
		# Process data
		sim = process_data(sim)

		sorted_index = np.argsort(sim.bh['mass'])[::-1]

		sink_ids = sim.bh['iord'][sorted_index]

		main_sinks = [19989587, 20886862, 24803303]
		report_sinks = [19989587, 8662889, 26041825, 25183230, 24803303, 21224590, 20886862]

		disk_characterization(sim)
		
	except FileNotFoundError:
		print(f"Error: File not found: {fname}")
		sys.exit(1)

if __name__ == '__main__':
	if len(sys.argv) != 2:
		print("Usage: python PLOT_CLOUD.py <data_file>, please provide <data_file> path!")
		sys.exit(1)

	fname = sys.argv[1]
	main(fname)
