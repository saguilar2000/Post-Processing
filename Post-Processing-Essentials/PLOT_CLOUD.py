"""
RUN USING PYTHON2
PYTHON MODULE TO PLOT QUANTITIES TO STUDY IN MASTER THESIS 
"""
import sys
import os
import argparse
from tkinter import font
from turtle import color
import numpy as np
import math
import pynbody
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import h5py
from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar
import matplotlib.font_manager as fm
from scipy.__config__ import show
# from functions import *
from params import *
from matplotlib.patches import Rectangle
import matplotlib.gridspec as gridspec

fontprops = fm.FontProperties(size=20)
marker_style = dict(color='w', marker='*', ls='',markeredgecolor='k')
plt.rcParams['text.usetex'] = True
props = dict(boxstyle='square', facecolor='w', alpha=0.5)

def species_dictionary(file = './info.dat'):
	""" From the info.dat file generated by KROME creates a dictionary of the species
	with their KROME names as the key, and 2 assigned values: their indexes in accord
	to the info.log file, and their masses [g] """
	f = open(file, 'r')
	lines = f.readlines()
	species = []
	indexes = []
	masses  = []
	for x in lines[:-4]:
		species.append(str(x.split('\t')[0]))
		indexes.append(int(x.split('\t')[1]))
		masses.append(float(x.split('\t')[2]))
	f.close()
	dict_indexs = dict(zip(species, indexes))
	dict_masses = dict(zip(species, masses))
	return dict_indexs, dict_masses

def SIGMA(r,rc,Sigma_c,gamma):
	"""Radial profile calculation function

	Args:
		r (int): _description_
		rc (int): _description_
		Sigma_c (int): _description_
		gamma (int): _description_

	Returns:
		Sigma (int): Radial distribution
	"""
	y = Sigma_c*(r/rc)**(-gamma)*np.exp(-(r/rc)**(2-gamma))
	return y

def define_labels(quantity,opt):
	physical = {"ntot":{"label":"\mathrm{Column\; Density}", "unit":"cm^{-2}", "cmap":"viridis", "av_z":False, "units":"cm^{-2}"},
			"rho":{"label":"\mathrm{Surface\; Density}", "unit":"g\;cm^{-2}", "cmap":"viridis", "av_z":False, "units":"g cm^-2"},
			"temp":{"label":"\mathrm{Temperature}", "unit":"K", "cmap":"magma", "av_z":"rho", "units":"K"},
			"Av":{"label":"\mathrm{A_{v}}", "unit":"mag", "cmap":"viridis", "av_z":False, "units":"mag"},
			"flux":{"label":"\mathrm{Flux}", "unit":"erg\;s^{-1}\;cm^{-2}", "cmap":"magma", "av_z":False, "units":"erg s^-1 cm^-2"}}
	if quantity in physical:
		label = physical[quantity]["label"]
		suptitle = label
		unit = physical[quantity]["unit"]
		units = physical[quantity]["units"]
		if opt=="log":clabel = rf"$\log{{{label}}}\;[{unit}]$"
		if opt=="lin":clabel = rf"${{{label}}}\;[{unit}]$"
		if opt=="loglog":clabel = rf"$\log{{{label}}}\;[{unit}]$"
		if opt=="semilogx":clabel = rf"${{{label}}}\;[{unit}]$"
		if opt=="semilogy":clabel = rf"$\log{{{label}}}\;[{unit}]$"
		cmap = physical[quantity]["cmap"]
		av_z = physical[quantity]["av_z"]
	else:
		if "DUST" in quantity:
			label = " ".join(quantity.split("_"))
		if quantity.isalpha():
			label = quantity
		if any(char.isdigit() for char in quantity):
			label = ''.join([f"_{char}" if char.isdigit() else char for char in quantity])
		if "+" in quantity or "-" in quantity:
			label = ''.join([f"^{char}" if char in ["+", "-"] else char for char in quantity])
		label = f"\mathrm{{{label}}}"
		suptitle = label
		unit = "cm^{-2}"
		units = "cm^-2"
		if opt=="log":clabel = rf"$\log{{{label}}}\;[{unit}]$"
		if opt=="lin":clabel = rf"${{{label}}}\;[{unit}]$"
		if opt=="loglog":clabel = rf"$\log{{{label}}}\;[{unit}]$"
		if opt=="semilogx":clabel = rf"${{{label}}}\;[{unit}]$"
		if opt=="semilogy":clabel = rf"$\log{{{label}}}\;[{unit}]$"
		cmap = "viridis"
		av_z = False 
	return label, suptitle, unit, clabel, cmap, av_z, units

def load_data(fname):
	"""Data loading from specified fname

	Args:
		fname (str): Data file name.

	Returns:
		sim (GadgetHDFSnap): Simulation data.
	"""
	sim = pynbody.load(fname)
	if ".hdf5" in fname: sim.properties["boxsize"] = sim.properties["boxsize"][0]
	return sim

def process_data(sim,recenter=None):
	"""Data process, this includes all necessary values and parameters to the data.
	
	Args:
		sim (GadgetHDFSnap): Simulation extracted data.
		recenter (list): If specified recenters the simulation in the given
						 coordinates as [x,y] (default None)

	Returns:
		sim (GadgetHDFSnap): Processed simulation data.
	"""
	gamma=7./5.
	mH=1.67e-24*pynbody.units.g # g
	mu=2.38
	kB=1.38069e-16*pynbody.units.Unit("cm^2 g s^-2 K^-1") # cm**2 g s**-2 K**-1
	kSB = 5.6704e-5*pynbody.units.Unit("erg cm^-2 s^-1 K^-4")
	conversion=((gamma-1)*mH*mu)/kB

	species, masses = species_dictionary()

	derivation = ((pynbody.units.G*pynbody.units.Unit("Msol")/pynbody.units.Unit("0.1 pc"))**(1,2)).in_units("cm s^-1")

	sim.set_units_system(
		velocity = f"{derivation} cm s^-1", 
		mass = "Msol",
		temperature = "K", 
		distance = "0.1 pc"
		)
	
	sim.g["rho"].convert_units("g cm^-3")
	sim.g["u"].convert_units("cm^2 s^-2")

	## Rescale smoothing length to match Gasoline's definition of kernel extending up to 2*h
	
	sim.g["smooth"] /= 2 # DEF: 2
	sim.g["ntot"] = pynbody.array.SimArray(sim.g["rho"], "g cm^-3")/mH/mu # TOTAL DENSITY DEFINITION
	sim.g["temp"] = (pynbody.array.SimArray(sim.g["u"], "cm^2 s^-2")*conversion).in_units('K')

	try:sim.g["RadEnergy"].units = pynbody.units.Unit("K")
	except:print("Data does not contain <RadEnergy>")
	try:sim.g["RadTemp"] = sim.g["RadEnergy"].in_units("K") # Lets assume it's temperature
	except:print("Data does not contain <RadTemp>")
	try:sim.g["Av"] = -np.log(pynbody.array.SimArray(sim.g["Extinction"]))
	except:print("Data does not contain <Extinction>")
	try:sim.g["flux"] = (kSB * (pynbody.array.SimArray(sim.g["RadTemp"], "K")**4)).in_units("erg s^-1 cm^-2") # S-Bs Law
	except:print("Data does not contain <Flux>")
	# print('Center coordinates (x,y): [%s,%s]'%(np.average(sim.g['x'], weights = sim.g['ntot']),np.average(sim.g['y'], weights = sim.g['ntot'])))
	if recenter is not None:
		sim["x"] -= recenter[0]
		sim["y"] -= recenter[1]
		sim["z"] -= np.average(sim.g["z"],weights = sim.g["ntot"])
	else:
		sim["x"] -= np.average(sim.g["x"], weights = sim.g["ntot"])
		sim["y"] -= np.average(sim.g["y"], weights = sim.g["ntot"])
		sim["z"] -= np.average(sim.g["z"], weights = sim.g["ntot"])

	if "KromeSpecies" in sim.g.loadable_keys():
		for i in species:
			j = species[i] - 1
			sim.g[i] = pynbody.array.SimArray(sim.g["KromeSpecies"][:, j]*sim.g["rho"]/masses[i], "cm^-3")
				
		for specie in species:
			if "_" not in specie:
				continue
			elif "META" in specie or "ANTA" in specie or "DUST" in specie or "GRAIN" in specie or "NH2D2+" in specie:
				continue				
			else:
				common_part = specie.split("_")[0]
				sim.g[common_part] = (sim.g[f"{common_part}_ORTHO"]+sim.g[f"{common_part}_PARA"])

	return sim

def profile(data,weight,width=500,resolution=1000,nbins=100):
	"""_summary_

	Args:
		data (_type_): _description_
		weight (_type_): _description_
		width (int, optional): _description_. Defaults to 500.
		resolution (int, optional): _description_. Defaults to 1000.
		nbins (int, optional): _description_. Defaults to 100.

	Returns:
		_type_: _description_
	"""
	flat_wght = weight.flatten()

	# Common binning for radial profiles
	pixpos = np.arange(0, resolution, 1)
	xpix,ypix = np.meshgrid(pixpos, pixpos)
	rpix = np.sqrt((xpix/resolution - 0.5)**2 + (ypix/resolution - 0.5)**2) * width
	rpix = rpix.flatten()
	rbins = np.logspace(np.log(1/resolution), 0, nbins) * width
	radius = (rbins[1:] + rbins[:-1]) / 2

	H_Qnty = np.histogram(rpix, bins = rbins, weights = flat_wght)
	Profile = (H_Qnty[0])/(resolution**2)/(np.pi*(rbins[1:]**2 - rbins[:-1]**2)) * width**2

	return radius, Profile

def plot_map(sim,quantity="rho",units="g cm^-2",opt="log",plot_sink=False,sink_id=None,scale=1,
			 add_suptitle=False,figname=None,cbar_limits=None,zoom_factor=None,ticks=False,
			 savefig=False,show=True,add_rectangle=False,sink_width=500,plot_prof=False,
			 add_contour=False,format="eps",plot_abundances=False,vscale=4):
	"""Plot a map of the data with colorbar and appropriate units.

	Args:
		sim (GadgetHDFSnap): Simulation extracted and processed data.
		quantity (str): Quantity name to plot, please ensure it's included in 
						the data (default: rho).
		units (str): The units of the quantity, make sure units are correct 
					 (default: rho units).
		opt (str): Wheter the map shows in logarithmic or linear scale (default: log).
		plot_sink (bool): Wheter to show a single sink or the entire simulation 
						  data (default: False).
		sink_id: If plot_sink is True you need to provide the sink ID you'd like 
				 to map (default: None).
		scale (int): Scale of the map (default: 1).
		add_suptitle (bool): Wheter to add a suptitle to the figure (default: False).
		figname (str): Add figname if specified (default: None).
		cbar_limits (list): If specified add list to limit the upper and 
							lower values in the colorbar (default: None).
		zoom_factor (int): If specified adds a zoom factor of the order 
						   'x zoom_factor' (default: None).
		ticks (bool): Turn on/off figure ticks (default: False/off).
		add_rectangle (bool): Wheter to add a rectangle in the center of 
							  the map (default: False).
		savefig (bool): Whether to save the figure (default: True).
		show (bool): Whether to display the figure (default: True).

	Returns: 
	matplotlib.pyplot.figure = Map figure.
	"""
	# Previous definitions for most of useful quantities.
	label, suptitle, unit, clabel, cmap, av_z, _ = define_labels(quantity,opt)

	# Define environment if plot_sink is specified or not
	if plot_sink:
		if sink_id is not None:
			sim['pos'] -= sim.bh['pos'][sim.bh['iord']==sink_id]
			# print('Sink mass = %s %s'%(sim.bh['mass'][sim.bh['iord']==sink_id],sim.bh['mass'].units))
		else:
			print('Please select SINK:\n')
			for i, mass in enumerate(sorted(sim.bh['mass'],reverse=True)):
				print('SINK #%s: %s [%s]'%(sim.bh['iord'][sim.bh['mass']==mass],mass,sim.bh['mass'].units))
			iord = input('Insert iord: ')
			sim['pos'] -= sim.bh['pos'][sim.bh['iord']==iord]
			# print('Sink mass = %s %s'%(sim.bh['mass'][sim.bh['iord']==iord],sim.bh['mass'].units))
		# plane = sim[pynbody.filt.BandPass('z', np.min(sim.g['z']), np.max(sim.g['z']))]
		plane = sim[pynbody.filt.Sphere(radius=sink_width+sink_width*0.1,cen=np.zeros(3))]

	else:
		plane = sim[pynbody.filt.BandPass('z', np.min(sim.g['z']), np.max(sim.g['z']))]
	
	# Variable definition
	data = plane
	opt = opt
	resolution = 1000 * 4

	# Figure dimentions definition using data
	if plot_sink:
		try:
			width=sink_width
		except:
			print("Please provide a <sink_width> value in AU units")
		height=width
	else:
		height=(max(data.g['y'])-min(data.g['y']))*0.1*scale
		width=(max(data.g['x'])-min(data.g['x']))*0.1*scale	#max(abs(data.g['r']))*2

	height_data = height
	width_data = width
	fig_width = 10  # Width of the figure in inches
	fig_height = (fig_width * height_data) / width_data 

	if plot_prof:
		fig,ax=plt.subplots(figsize=(fig_width*2,fig_height))
		ax = plt.subplot(121)
	else:
		fig,ax=plt.subplots(figsize=(fig_width,fig_height))

	width=width*2

	if plot_sink:
		# Image generation using 'pynbody.plot.sph.image(...)'
		# add data masking for maps to take at most a cube with width = disk extent
		IMG = pynbody.plot.sph.image(data.g, qty = quantity, units = units, 
			width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
			resolution = resolution)
		# Replace zeros with low values
		IMG[np.where(IMG==0)]=1e-5
	else:
		# Image generation using 'pynbody.plot.sph.image(...)'
		IMG = pynbody.plot.sph.image(data.g, qty = quantity, units = units, 
			width = '%.3f pc'%(width), noplot = True, log = False, av_z = av_z, 
			resolution = resolution)#,threaded=False)
		# Replace zeros with low values
		IMG[np.where(IMG==0)]=1e-5

	# Extent definition
	extent = [-width/2.,width/2.,-width/2.,width/2.]

	# Colorbar scale selection
	if 'log' in opt:
		if quantity=="temp":
			vmax=np.log10(np.amax(IMG.flatten()))
			vmin=np.log10(1)#vmax-2
		else:
			if cbar_limits is not None:
				vmax=cbar_limits[0]
				vmin=cbar_limits[1]
			else:
				vmax=np.log10(np.amax(IMG.flatten()))
				vmin=vmax-vscale
		fig1 = ax.imshow(np.log10(IMG)[::-1],cmap=cmap,extent=extent, vmin=vmin, vmax=vmax, aspect='auto')
	
	elif 'linear' in opt or 'lin' in opt:
		vmax=np.amax(IMG.flatten())
		vmin=np.amin(IMG.flatten())#vmax-100
		fig1 = ax.imshow(IMG,cmap=cmap,extent=extent, vmin=vmin, vmax=vmax, aspect='auto')

	# Sinks plotting
	if plot_sink:
		ax.plot(data.bh['x'].in_units('au'),data.bh['y'].in_units('au'),'w.',fillstyle='full',markersize=10)
	else:
		###### CHANGE THIS INTO AU AND PC UNITS
		ax.plot(data.bh['x']*0.1,data.bh['y']*0.1,'w.',fillstyle='full',markersize=10)#,**marker_style) # *0.1 TO MATCH THE SCALE
	
	# Set figure limits
	if plot_sink:
		ax.set_xlim(extent[0],extent[1])
		ax.set_ylim(extent[2],extent[3])
	else:
		ax.set_xlim(min(data.g['x'])*0.1*scale, max(data.g['x'])*0.1*scale) # *0.1 TO MATCH THE SCALE
		ax.set_ylim(min(data.g['y'])*0.1*scale, max(data.g['y'])*0.1*scale) # *0.1 TO MATCH THE SCALE
	
	# Zoom factor ussage
	if zoom_factor is not None:
		xlim = ax.get_xlim()
		ylim = ax.get_ylim()
		x_center = (xlim[0] + xlim[1]) / 2
		y_center = (ylim[0] + ylim[1]) / 2
		x_width = (xlim[1] - xlim[0]) / (zoom_factor)
		y_width = (ylim[1] - ylim[0]) / (zoom_factor)
		ax.set_xlim(x_center - x_width, x_center + x_width)
		ax.set_ylim(y_center - y_width, y_center + y_width)

	# Extract figure limits
	left, right = ax.get_xlim()
	down, up = ax.get_ylim()

	# Include time in figure
	if '.hdf5' in fname:
		head = h5py.File(fname, 'r')
		time = np.round(head['Header'].attrs['Time']*471300, 1) # kyr
		head.close()
		ax.text(right-right*.05,up-up*.05,'%s yrs'%int(time[0]), color='white', fontproperties=fontprops,ha='right',va='top')

	else:
		ax.text(right-right*.05,up-up*.05,'228293 yrs', color='white', fontproperties=fontprops,ha='right',va='top')

	# Set axis lengths and define scale-bar lengths in pc and AU
	x_axis_length = right-left
	y_axis_length = up - down

	bar_lenghts_pc = [100,50,10,5,1,0.5,0.3,0.05,0.01,0.005,0.001, 
						0.0005,0.0001,0.00005,0.00001]
	bar_lenghts_au = [5000,1000,500,100,50,10,5,1,0.5,0.1,0.05,0.01]

	# Scale-bar ussage
	if plot_sink:
		bar_length = x_axis_length#*0.1*206300.
		bar = bar_length*.1 #min(bar_lenghts_au, key=lambda x: abs(x - bar_length))
		scalebar = AnchoredSizeBar(ax.transData,
								bar, '%d AU'%(bar), 
								'lower right', 
								pad=0.1,
								color='white',
								frameon=False,
								size_vertical=bar/100,
								fontproperties=fontprops
								)

	else:
		bar_length = x_axis_length*0.1
		bar = min(bar_lenghts_pc, key=lambda x: abs(x - bar_length))
		decimals = int(-math.floor(math.log10(bar)))
		scalebar = AnchoredSizeBar(ax.transData,
								bar, '%.*f pc'%(decimals,bar), 
								'lower right', 
								pad=0.1,
								color='white',
								frameon=False,
								size_vertical=bar/20,
								fontproperties=fontprops
								)

	ax.add_artist(scalebar)

	# Figure adjust
	# fig.subplots_adjust(bottom=0.05, top=0.95, left=0.05, right=0.85,
	# 					wspace=0.1, hspace=0.)
	fig.subplots_adjust(bottom=0.05, top=0.95, left=0.05, right=0.95,
						wspace=0.1, hspace=0.)
	
	if add_contour:
		cont_label, cont_suptitle, cont_unit, cont_clabel, cont_cmap, cont_av_z, _ = define_labels("H2O","log")
		IMGF = pynbody.plot.sph.image(data.g, qty = "H2O", units = "cm^-2", 
				width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
				resolution = resolution)
		# Replace zeros with low values
		IMGF[np.where(IMGF==0)]=1e-5
		
		## Common contouring stuff
		sz = width/2.
		partition = np.linspace(-sz, sz, resolution)
		Xpix,Ypix = np.meshgrid(partition, partition)

		# Cant = plt.contourf(Xpix, Ypix, np.log10(IMGF), cmap = "viridis", vmin = 9.4, vmax = 9.5, levels = None)
		# for c in Cant.collections:
		# 	c.set_edgecolor('face')

		print(np.log10(IMGF.min()),np.log10(IMGF.max()))
		
		Cont = ax.contour(Xpix, Ypix, np.log10(IMGF), cmap = "cividis", levels = np.arange(9.4,9.5,0.01), linewidths = 1.2,
				vmin = 9.4, vmax = 9.5) # linestyles = [':', '-.', '--', '-'],
		
		Cbar_c = fig.colorbar(Cont,ax=ax)#label = clabel)
		Cbar_c.ax.set_ylabel(cont_clabel,fontproperties=fontprops)


	# Color bar inclussion
	# cb_ax = fig.add_axes([0.87, 0.05, 0.03, 0.90])
	Cbar = fig.colorbar(fig1, ax=ax)
	Cbar.ax.set_ylabel(clabel,fontproperties=fontprops)

	# Add rectangle enclosing figure center
	if add_rectangle:
		r_height = y_axis_length*0.1/2
		r_width = x_axis_length*0.1/2
		r_center_x, r_center_y = np.zeros(2)
		x = r_center_x - (r_width / 2)
		y = r_center_y - (r_height / 2)
		
		ax.add_patch(Rectangle((x, y), r_width, r_height,facecolor='none',edgecolor='k',ls='--'))

	# Ticks on/off
	if not ticks:
		ax.set_yticks([])
		ax.set_xticks([])

	# Suptitle addition
	if add_suptitle and '.hdf5' in fname:
		numb = fname.split('/')[-1].split('_')[1].split('.')[0]
		# fig.suptitle(f"Snapshot\_{numb} {suptitle} Map",fontproperties=fontprops)
		fig.suptitle(f"{suptitle} Map",fontproperties=fontprops)
	if add_suptitle and '.gadget' in fname:
		numb = fname.split('.')[0][-4:]
		fig.suptitle(f"CIM\_{numb} {suptitle} Map",fontproperties=fontprops)
	
	if plot_prof:
		# Profile plotting

		# profiles = ["rho","CO","H2O","HCO+","H2"]
		profiles = ["H2O","CO"]
		# profiles = ["H2O"]
		opt = "semilogy"
		ax_p = fig.add_subplot(122)

		if vmin==None:vmin = np.amin(IMG.flatten())
		if vmax==None:vmax = np.amax(IMG.flatten())

		for prof in profiles:
			label, suptitle, unit, clabel, cmap, av_z, prof_units = define_labels(prof,opt)
			prof_data = data.g[pynbody.filt.Disc(radius=width,height=width*0.2,cen=np.zeros(3))]
			min_rho = max(prof_data.g['rho']) - max(prof_data.g['rho'])*0.999
			env_data = prof_data
			disk_data = prof_data[pynbody.filt.HighPass('rho', min_rho)]


			if plot_sink:
				# Image generation using 'pynbody.plot.sph.image(...)'
				disk_IMG = pynbody.plot.sph.image(disk_data.g, qty = prof, units = prof_units, 
					width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
					resolution = resolution)
				# Replace zeros with low values
				# disk_IMG[np.where(disk_IMG==0)]=1e-5
				# aux_fig, aux_ax = plt.subplots(figsize=(fig_width,fig_height))
				# aux_ax.imshow(np.log10(disk_IMG)[::-1], cmap=cmap, vmin=None, vmax=None, extent=extent, aspect='auto')
				# plt.show()
				# Image generation using 'pynbody.plot.sph.image(...)'
				env_IMG = pynbody.plot.sph.image(env_data.g, qty = prof, units = prof_units, 
					width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
					resolution = resolution)
				# Replace zeros with low values
				# env_IMG[np.where(env_IMG==0)]=1e-5
			else:
				# Image generation using 'pynbody.plot.sph.image(...)'
				disk_IMG = pynbody.plot.sph.image(disk_data.g, qty = prof, units = prof_units, 
					width = '%.3f pc'%(width), noplot = True, log = False, av_z = av_z, 
					resolution = resolution)#,threaded=False)
				# Replace zeros with low values
				# disk_IMG[np.where(disk_IMG==0)]=1e-5
				# Image generation using 'pynbody.plot.sph.image(...)'
				env_IMG = pynbody.plot.sph.image(env_data.g, qty = prof, units = prof_units, 
					width = '%.3f pc'%(width), noplot = True, log = False, av_z = av_z, 
					resolution = resolution)#,threaded=False)
				# Replace zeros with low values
				# env_IMG[np.where(env_IMG==0)]=1e-5

			if plot_abundances: # fix this
				H2_disk_weight = pynbody.plot.sph.image(disk_data.g, qty = 'H2', units = 'cm^-2', 
					width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
					resolution = resolution)
				# H2_disk_weight[np.where(H2_disk_weight==0)]=1e-5
				H2_env_weight = pynbody.plot.sph.image(env_data.g, qty = 'H2', units = 'cm^-2', 
					width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
					resolution = resolution)
				# H2_env_weight[np.where(H2_env_weight==0)]=1e-5
			
			disk_weight = disk_IMG
			env_weight = env_IMG

			# plt.imshow(prof_IMG, cmap=cmap, extent=extent, aspect='auto')
			# plt.show()
			nbins = 500
			if plot_abundances:
				disk_radius,sp_disk_Profile = profile(data=prof_data,weight=disk_weight,width=width,resolution=resolution,nbins=nbins)
				env_radius,sp_env_Profile = profile(data=prof_data,weight=env_weight,width=width,resolution=resolution,nbins=nbins)
				H2_disk_radius,H2_disk_Profile = profile(data=prof_data,weight=H2_disk_weight,width=width,resolution=resolution,nbins=nbins)
				H2_env_radius,H2_env_Profile = profile(data=prof_data,weight=H2_env_weight,width=width,resolution=resolution,nbins=nbins)
				disk_Profile = sp_disk_Profile / H2_disk_Profile
				env_Profile = sp_env_Profile / H2_env_Profile
			else:
				disk_radius,disk_Profile = profile(data=prof_data,weight=disk_weight,width=width,resolution=resolution,nbins=nbins)
				env_radius,env_Profile = profile(data=prof_data,weight=env_weight,width=width,resolution=resolution,nbins=nbins)
			
			line_color,=ax_p.plot(disk_radius, disk_Profile,label=rf"${label}\;[{unit}]$ disk")
			#ax_p.plot(env_radius, env_Profile,label=rf"${label}\;[{unit}]$ disk + env",color=line_color.get_color(),linestyle='--')
			
			if plot_sink:
				r_unit = "AU"
			else:
				r_unit = "pc"

			if opt=="lin":ax_p.plot()
			if opt=="loglog":ax_p.loglog()
			if opt=="semilogx":ax_p.semilogx()
			if opt=="semilogy":ax_p.semilogy()
			
			if len(profiles) > 1:
				# ax_p.legend(loc='upper right',prop=fontprops)
				fontp = fm.FontProperties(size=13)
				# ax_p.legend(prop=fontp,loc='lower right')
				ax_p.legend(prop=fontp)
				if opt=="lin":
					xlabel = rf"$R\;[{r_unit}]$"
					ylabel = rf"$\mathrm{{Quantity}}$"
				if opt=="loglog":
					xlabel = rf"$\log\;R\;[{r_unit}]$"
					ylabel = rf"$\log{{\mathrm{{Quantity}}}}$"
				if opt=="semilogx":
					xlabel = rf"$\log\;R\;[{r_unit}]$"
					ylabel = rf"$\mathrm{{Quantity}}$"
				if opt=="semilogy":
					xlabel = rf"$R\;[{r_unit}]$"
					ylabel = rf"$\log{{\mathrm{{Quantity}}}}$"
				ax_p.set_xlabel(xlabel,fontproperties=fontprops)
				ax_p.set_ylabel(ylabel,fontproperties=fontprops)

			else:
				if opt=="lin":
					xlabel = rf"$R\;[{r_unit}]$"
					ylabel = rf"${{{label}}}\;[{unit}]$"
				if opt=="loglog":
					xlabel = rf"$\log\;R\;[{r_unit}]$"
					ylabel = rf"$\log{{{label}}}\;[{unit}]$"
				if opt=="semilogx":
					xlabel = rf"$\log\;R\;[{r_unit}]$"
					ylabel = rf"${{{label}}}\;[{unit}]$"
				if opt=="semilogy":
					xlabel = rf"$R\;[{r_unit}]$"
					ylabel = rf"$\log{{{label}}}\;[{unit}]$"
				ax_p.set_xlabel(xlabel)
				ax_p.set_ylabel(ylabel)
			# ax_p.set_xlim(disk_radius[0],disk_radius[-1])
			# ax_p.set_xlim(disk_radius[0],150)
			# ax_p.set_ylim(np.max(disk_Profile) - 10 ,np.max(disk_Profile))

	# Savefig options
	if savefig:
		dpi = 300
		path = "Images"
		# If figname specified, set figname
		if figname is not None:
			print('Generating %s'%figname)
			plt.savefig(f"{path}/{figname}.{format}",dpi=dpi,format=format)
		# If figname not specified, set common figname using parameters
		else:
			if plot_sink:
				object='SINK'
				percent=int(scale*100)
				print('Generating %s_%s_%s_map'%(object,quantity,percent))
				plt.savefig(f"{path}/{object}_{quantity}_{percent}_map.{format}",dpi=dpi,format=format)#, bbox_inches = 'tight')
			else:
				if '.hdf5' in fname:
					object='SUBREGION'
				if '.gadget' in fname:
					object='CLOUD'
				print('Generating %s_%s_map'%(object,quantity))
				plt.savefig(f"{path}/{object}_{quantity}_map.{format}",dpi=dpi,format=format)#, bbox_inches = 'tight')
	
	# Figure show on/off
	if show:
		plt.show()
	
	plt.cla()
	plt.clf()
	plt.close()

def plot_prof(sim, prof = "CO", units = "cm^-2",plot_sink = True, scale = 1, sink_width = 500, opt = "log", cbar_limits = None, 
			  plot_abundances = False, sink_id = None, add_suptitle = False, figname = None, savefig = False, show = True, 
			  format = "eps", nbins = 100):
	
	# Variable definition
	label, suptitle, prof_units, clabel, cmap, av_z, _ = define_labels(prof,opt)

	# Define environment if plot_sink is specified or not
	if plot_sink:
		if sink_id is not None:
			sim['pos'] -= sim.bh['pos'][sim.bh['iord']==sink_id]
		else:
			print('Please select SINK:\n')
			for i, mass in enumerate(sorted(sim.bh['mass'],reverse=True)):
				print('SINK #%s: %s [%s]'%(sim.bh['iord'][sim.bh['mass']==mass],mass,sim.bh['mass'].units))
			iord = input('Insert iord: ')
			sim['pos'] -= sim.bh['pos'][sim.bh['iord']==iord]
		plane = sim[pynbody.filt.Sphere(radius=sink_width+sink_width*0.1,cen=np.zeros(3))]

	else:
		plane = sim[pynbody.filt.BandPass('z', np.min(sim.g['z']), np.max(sim.g['z']))]

	data = plane
	resolution = 1000 * 4
	opt = opt

	# Figure dimentions definition using data
	if plot_sink:
		try:
			width=sink_width
		except:
			print("Please provide a <sink_width> value in AU units")
		height=width
	else:
		height=(max(data.g['y'])-min(data.g['y']))*0.1*scale
		width=(max(data.g['x'])-min(data.g['x']))*0.1*scale	#max(abs(data.g['r']))*2

	height_data = height
	width_data = width
	fig_width = 10  # Width of the figure in inches
	fig_height = (fig_width * height_data) / width_data 

	prof_data = data.g[pynbody.filt.Disc(radius=width,height=width*0.2,cen=np.zeros(3))]
	min_rho = max(prof_data.g['rho']) - max(prof_data.g['rho'])*0.999
	env_data = prof_data
	disk_data = prof_data[pynbody.filt.HighPass('rho', min_rho)]

	fig, ax = plt.subplots(figsize=(fig_width*2,fig_height))
	ax = plt.subplot(121)

	if plot_sink:
		# Image generation using 'pynbody.plot.sph.image(...)'
		disk_IMG = pynbody.plot.sph.image(disk_data.g, qty = prof, units = units, 
			width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
			resolution = resolution)
		# Image generation using 'pynbody.plot.sph.image(...)'
		env_IMG = pynbody.plot.sph.image(env_data.g, qty = prof, units = units, 
			width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
			resolution = resolution)
		if plot_abundances: # fix this
			H2_disk_weight = pynbody.plot.sph.image(disk_data.g, qty = 'H2', units = 'cm^-2', 
				width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
				resolution = resolution)
			H2_env_weight = pynbody.plot.sph.image(env_data.g, qty = 'H2', units = 'cm^-2', 
				width = '%.3f au'%(width), noplot = True, log = False, av_z = av_z, 
				resolution = resolution)
	else:
		# Image generation using 'pynbody.plot.sph.image(...)'
		disk_IMG = pynbody.plot.sph.image(disk_data.g, qty = prof, units = prof_units, 
			width = '%.3f pc'%(width), noplot = True, log = False, av_z = av_z, 
			resolution = resolution)#,threaded=False)
		env_IMG = pynbody.plot.sph.image(env_data.g, qty = prof, units = prof_units, 
			width = '%.3f pc'%(width), noplot = True, log = False, av_z = av_z, 
			resolution = resolution)#,threaded=False)
		if plot_abundances: # fix this
			H2_disk_weight = pynbody.plot.sph.image(disk_data.g, qty = 'H2', units = 'cm^-2', 
				width = '%.3f pc'%(width), noplot = True, log = False, av_z = av_z, 
				resolution = resolution)
			H2_env_weight = pynbody.plot.sph.image(env_data.g, qty = 'H2', units = 'cm^-2', 
				width = '%.3f pc'%(width), noplot = True, log = False, av_z = av_z, 
				resolution = resolution)
	
		
	# width=width*2

	# Extent definition
	# extent = [-width/2.,width/2.,-width/2.,width/2.]
	extent = [-width,width,-width,width]

	if plot_abundances:
		map_IMG = env_IMG / H2_env_weight
	else:
		map_IMG = disk_IMG
		map_IMG[np.where(map_IMG==0)]=1e-5
	
	# Colorbar scale selection
	if 'log' in opt:
		if prof=="temp":
			vmax=np.log10(np.amax(map_IMG.flatten()))
			vmin=np.log10(1)#vmax-2
		else:
			if cbar_limits is not None:
				vmax=cbar_limits[0]
				vmin=cbar_limits[1]
			else:
				vmax=np.log10(np.amax(map_IMG.flatten()))
				vmin=vmax-4
				# vmin=np.log10(np.amin(map_IMG.flatten()))
		fig1 = ax.imshow(np.log10(map_IMG)[::-1],cmap=cmap,extent=extent, vmin=vmin, vmax=vmax, aspect='auto')
	elif 'linear' in opt or 'lin' in opt:
		vmax=np.amax(map_IMG.flatten())
		vmin=np.amin(map_IMG.flatten())#vmax-100
		fig1 = ax.imshow(map_IMG,cmap=cmap,extent=extent, vmin=vmin, vmax=vmax, aspect='auto')

	# Sinks plotting
	# if plot_sink:
	# 	ax.plot(prof_data.bh['x'].in_units('au'),data.bh['y'].in_units('au'),'w.',fillstyle='full',markersize=10)
	# else:
	# 	###### CHANGE THIS INTO AU AND PC UNITS
	# 	ax.plot(prof_data.bh['x']*0.1,data.bh['y']*0.1,'w.',fillstyle='full',markersize=10)#,**marker_style) # *0.1 TO MATCH THE SCALE
	
	# Set figure limits
	if plot_sink:
		ax.set_xlim(extent[0],extent[1])
		ax.set_ylim(extent[2],extent[3])
	else:
		ax.set_xlim(min(prof_data.g['x'])*0.1*scale, max(prof_data.g['x'])*0.1*scale) # *0.1 TO MATCH THE SCALE
		ax.set_ylim(min(prof_data.g['y'])*0.1*scale, max(prof_data.g['y'])*0.1*scale) # *0.1 TO MATCH THE SCALE

	# Extract figure limits
	left, right = ax.get_xlim()
	down, up = ax.get_ylim()

	# Set axis lengths and define scale-bar lengths in pc and AU
	x_axis_length = right-left
	y_axis_length = up - down

	bar_lenghts_pc = [100,50,10,5,1,0.5,0.3,0.05,0.01,0.005,0.001, 
						0.0005,0.0001,0.00005,0.00001]
	bar_lenghts_au = [5000,1000,500,100,50,10,5,1,0.5,0.1,0.05,0.01]

	# Scale-bar ussage
	if plot_sink:
		bar_length = x_axis_length#*0.1*206300.
		bar = bar_length*.1 #min(bar_lenghts_au, key=lambda x: abs(x - bar_length))
		scalebar = AnchoredSizeBar(ax.transData,
								bar, '%d AU'%(bar), 
								'lower right', 
								pad=0.1,
								color='white',
								frameon=False,
								size_vertical=bar/100,
								fontproperties=fontprops
								)
	else:
		bar_length = x_axis_length*0.1
		bar = min(bar_lenghts_pc, key=lambda x: abs(x - bar_length))
		decimals = int(-math.floor(math.log10(bar)))
		scalebar = AnchoredSizeBar(ax.transData,
								bar, '%.*f pc'%(decimals,bar), 
								'lower right', 
								pad=0.1,
								color='white',
								frameon=False,
								size_vertical=bar/20,
								fontproperties=fontprops
								)

	ax.add_artist(scalebar)	

	fig.subplots_adjust(bottom=0.05, top=0.95, left=0.05, right=0.95,
						wspace=0.1, hspace=0.)
	
	Cbar = fig.colorbar(fig1, ax=ax)
	Cbar.ax.set_ylabel(clabel,fontproperties=fontprops)
	
	# ax.set_yticks([])
	# ax.set_xticks([])

	# profiles = ["rho","CO","H2O","HCO+","H2"]
	# profiles = []
	# profiles.append[prof]
	# # profiles = ["H2O"]
	opt = "semilogy"
	ax_p = fig.add_subplot(122)

	if vmin==None:vmin = np.amin(disk_IMG.flatten())
	if vmax==None:vmax = np.amax(disk_IMG.flatten())

	disk_weight = disk_IMG
	env_weight = env_IMG
	
	if plot_abundances:
		disk_radius,sp_disk_Profile = profile(data=prof_data,weight=disk_weight,width=width,resolution=resolution,nbins=nbins)
		env_radius,sp_env_Profile = profile(data=prof_data,weight=env_weight,width=width,resolution=resolution,nbins=nbins)
		_,H2_disk_Profile = profile(data=prof_data,weight=H2_disk_weight,width=width,resolution=resolution,nbins=nbins)
		_,H2_env_Profile = profile(data=prof_data,weight=H2_env_weight,width=width,resolution=resolution,nbins=nbins)
		disk_Profile = sp_disk_Profile / H2_disk_Profile
		env_Profile = sp_env_Profile / H2_env_Profile
	else:
		disk_radius,disk_Profile = profile(data=prof_data,weight=disk_weight,width=width,resolution=resolution,nbins=nbins)
		env_radius,env_Profile = profile(data=prof_data,weight=env_weight,width=width,resolution=resolution,nbins=nbins)
	
	nonzero_disk = np.where(disk_Profile != 0) # removing 0 values
	disk_radius = disk_radius[nonzero_disk]
	disk_Profile = disk_Profile[nonzero_disk]
	nonzero_env = np.where(env_Profile!=0) # removing 0 values	
	env_radius = env_radius[nonzero_env]
	env_Profile = env_Profile[nonzero_env]
	line_color,=ax_p.plot(disk_radius, disk_Profile,label=rf"${label}\;[{prof_units}]$ disk")
	ax_p.plot(env_radius, env_Profile,label=rf"${label}\;[{prof_units}]$ disk + env",color=line_color.get_color(),linestyle='--')
	
	if plot_sink:
		r_unit = "AU"
	else:
		r_unit = "pc"

	if opt=="lin":ax_p.plot()
	if opt=="loglog":ax_p.loglog()
	if opt=="semilogx":ax_p.semilogx()
	if opt=="semilogy":ax_p.semilogy()
	
	# if len(profiles) > 1:
	# 	# ax_p.legend(loc='upper right',prop=fontprops)
	# 	fontp = fm.FontProperties(size=13)
	# 	# ax_p.legend(prop=fontp,loc='lower right')
	# 	ax_p.legend(prop=fontp)
	# 	if opt=="lin":
	# 		xlabel = rf"$R\;[{r_unit}]$"
	# 		ylabel = rf"$\mathrm{{Quantity}}$"
	# 	if opt=="loglog":
	# 		xlabel = rf"$\log\;R\;[{r_unit}]$"
	# 		ylabel = rf"$\log{{\mathrm{{Quantity}}}}$"
	# 	if opt=="semilogx":
	# 		xlabel = rf"$\log\;R\;[{r_unit}]$"
	# 		ylabel = rf"$\mathrm{{Quantity}}$"
	# 	if opt=="semilogy":
	# 		xlabel = rf"$R\;[{r_unit}]$"
	# 		ylabel = rf"$\log{{\mathrm{{Quantity}}}}$"
	# 	ax_p.set_xlabel(xlabel,fontproperties=fontprops)
	# 	ax_p.set_ylabel(ylabel,fontproperties=fontprops)

	# else:
	if opt=="lin":
		xlabel = rf"$R\;[{r_unit}]$"
		ylabel = rf"${{{label}}}\;[{prof_units}]$"
	if opt=="loglog":
		xlabel = rf"$\log\;R\;[{r_unit}]$"
		ylabel = rf"$\log{{{label}}}\;[{prof_units}]$"
	if opt=="semilogx":
		xlabel = rf"$\log\;R\;[{r_unit}]$"
		ylabel = rf"${{{label}}}\;[{prof_units}]$"
	if opt=="semilogy":
		xlabel = rf"$R\;[{r_unit}]$"
		ylabel = rf"$\log{{{label}}}\;[{prof_units}]$"
	ax_p.set_xlabel(xlabel)
	ax_p.set_ylabel(ylabel)
	ax_p.set_xlim(disk_radius[0],disk_radius[-1])
	ymax = np.max(disk_Profile)
	ymin = 10 ** (np.log10(ymax) - 30) if ymax > 0 else 0.0
	ymax = 10 ** (np.log10(ymax) + 1)

    # Set ymin and ymax based on the first non-zero value
	# ax_p.set_ylim(ymin,ymax)

	plt.show()
		
def plot_sinks(sim,quantity="rho",units="g cm^-2",opt="log",add_suptitle=False,
			   figname=None,cbar_limits=None,ticks=False,savefig=False,show=True):
	
	physical = {"ntot":{"label":"\mathrm{Column\; Density}", "unit":"cm^{-2}", "cmap":"viridis", "av_z":False},
			"rho":{"label":"\mathrm{Surface\; Density}", "unit":"g\;cm^{-2}", "cmap":"viridis", "av_z":False},
			"temp":{"label":"\mathrm{Temperature}", "unit":"K", "cmap":"magma", "av_z":"rho"},
			"Av":{"label":"\mathrm{A_{v}}", "unit":"mag", "cmap":"viridis", "av_z":False},
			"flux":{"label":"\mathrm{Flux}", "unit":"erg\;s^{-1}\;cm^{-2}", "cmap":"magma", "av_z":False}}

	if quantity in physical:
		label = physical[quantity]["label"]
		suptitle = label
		unit = physical[quantity]["unit"]
		if opt=="log":clabel = rf"$\log{{{label}}}\;[{unit}]$"
		if opt=="lin":clabel = rf"${{{label}}}\;[{unit}]$"
		cmap = physical[quantity]["cmap"]
		av_z = physical[quantity]["av_z"]
	else:
		if quantity.isalpha():
			label = quantity
		if any(char.isdigit() for char in quantity):
			label = ''.join([f"_{char}" if char.isdigit() else char for char in quantity])
		if "+" in quantity or "-" in quantity:
			label = ''.join([f"^{char}" if char in ["+", "-"] else char for char in label])
		label = f"\mathrm{{{label}}}"
		suptitle = label
		unit = "cm^{-2}"
		if opt=="log":clabel = rf"$\log{{{label}}}\;[{unit}]$"
		if opt=="lin":clabel = rf"${{{label}}}\;[{unit}]$"
		cmap = "viridis"
		av_z = False 
	# Disk hosting sinks IDs
	disks = {"Disk 1":[8662889,19989587],
			 "Disk 2":[25183230,26041825,27780117],
			 "Disk 3":[16476422,18690248,21409293],
			 "Disk 4":[24803303,26335945],
			 "Disk 5":[15530339,26549431],
			 "Disk 6":[5935534],
			 "Disk 7":[21224590],
			 "Disk 8":[16112123],
			 "Disk 9":[20886862]}
	
	vrange = {1:[3.25, 1.0],
			  2:[4.5, 0.0],
			  3:[2.5,0.0]}
	
	single_sinks = {key: value for key, value in disks.items() if len(value) == 1}
	binary_sinks = {key: value for key, value in disks.items() if len(value) == 2}
	multiple_sinks = {key: value for key, value in disks.items() if len(value) > 2}

	systems = [single_sinks,binary_sinks,multiple_sinks]

	for system in systems:
		if len(system) < 4:
			nrows = 1
		else:
			nrows = 2
		ncols = int(len(system)/nrows)
		print(ncols)
		fig, axes = plt.subplots(figsize=(14,8),nrows=nrows,ncols=ncols,sharex=True,sharey=True)

		for ax, params in zip(axes.flatten(),system.items()):
			disk, ids = params
			if len(ids) == 1:
				id = ids[0]
				sim['pos'] -= sim.bh['pos'][sim.bh['iord']==id]
			else:
				index = [sim.bh['iord']==id for id in ids]
				masses = sim.bh['mass'][np.nonzero(index)[-1]]
				max_mass = masses[masses.argmax()]
				sim['pos'] -= sim.bh['pos'][sim.bh['mass']==max_mass]
			
			data = sim
			width = 200
			resolution = 1000 * 4
			extent = [-width/2.,width/2.,-width/2.,width/2.]
			
			IMG = pynbody.plot.sph.image(data.g, qty = quantity, units = units, width = '%.3f au'%(width), 
										noplot = True, log = False, av_z = av_z, resolution = resolution)
			# Replace zeros with low values
			IMG[np.where(IMG==0)]=1e-5
			
			vmax,vmin = vrange[len(ids)]
			
			fig1 = ax.imshow(np.log10(IMG)[::-1],cmap=cmap, extent = extent,vmin=vmin, vmax=vmax, aspect='equal')
			ax.plot(data.bh['x'].in_units('au'),data.bh['y'].in_units('au'),'w.',fillstyle='full',markersize=10)

			ax.set_xlim(extent[0], extent[1])
			ax.set_ylim(extent[2], extent[3])

			ax.set_yticks([])
			ax.set_xticks([])

		fig.subplots_adjust(bottom=0.05,top=0.95,left=0.05,right=0.85,wspace=0.,hspace=0.)

		# Color bar inclussion
		cb_ax = fig.add_axes([0.87, 0.05, 0.03, 0.90])
		Cbar = fig.colorbar(fig1, cax=cb_ax)
		Cbar.ax.set_ylabel(clabel,fontproperties=fontprops)

		# Suptitle addition
		if add_suptitle and '.hdf5' in fname:
			numb = fname.split('/')[-1].split('_')[1].split('.')[0]
			# fig.suptitle(f"Snapshot\_{numb} Sink {suptitle} Map",fontproperties=fontprops)
			fig.suptitle(f"{suptitle} Map",fontproperties=fontprops)
		if add_suptitle and '.gadget' in fname:
			numb = fname.split('.')[0][-4:]
			fig.suptitle(f"CIM\_{numb} Sink {suptitle} Map",fontproperties=fontprops)


		if show: 
			plt.show()
			plt.cla()
			plt.clf()
			plt.close()
		if savefig: ############ CHECK THIS BEFORE USING
			dpi = 300
			format = "pdf"
			path = "species_maps"
			plt.savefig(f"{path}/{quantity}_map.{format}",dpi=dpi,format=format)
			plt.cla()
			plt.clf()
			plt.close()

def is_keplerian(sim,sink_id,check=False,width=None,remove_background=False): # FIX FOR RELATIVE VELOCITIES AND POSITIONS!!!!!!!
	"""Check if the simulation has a Keplerian orbit."""
	fig,ax = plt.subplots(figsize=(16,8),ncols=2)

	if width is not None:
		width = width
	else:
		width = "100 au"
	
	sim["pos"] -= sim.bh["pos"][sim.bh["iord"]==sink_id]
	sim = sim[pynbody.filt.Sphere(radius=width,cen=np.zeros(3))]
	print(sim.bh[''])
	if remove_background:
		sim.g = sim.g[pynbody.filt.HighPass('rho',np.mean(sim.g['rho']))]
	sim.g["vel"].convert_units("cm s**-1")
	sim.g['part_vel'] = np.sqrt(np.sum(pynbody.array.SimArray(sim.g['vel'],"cm s^-1")**2,axis=1))
	
	c_mass = sim.bh["mass"][sim.bh["iord"]==sink_id].in_units("g")[0]
	radius = sim.g["r"].in_units("cm")
	
	is_kepl = 0
	e_keplerian = np.sqrt(G * c_mass / radius)
	
	image =	pynbody.plot.sph.image(sim.g, qty='rho', width=width, resolution=500, 
			units='g cm^-2', log=True, av_z=False, clear=True, cmap='viridis', 
			show_cbar=True, noplot=True)
	image[np.where(image==0)]=1e-5
	vmax=np.log10(np.amax(image.flatten()))
	vmin=vmax-6	
	extent = [min(sim.g['x'].in_units('au')),
			  max(sim.g['x'].in_units('au')),
			  min(sim.g['y'].in_units('au')),
			  max(sim.g['y'].in_units('au'))]
	ax[0].imshow(np.log10(image)[::-1],extent=extent,vmin=vmin,vmax=vmax,cmap='viridis',aspect='auto')
	ax[0].plot(sim.bh['x'].in_units('au'),sim.bh['y'].in_units('au'),'w.',fillstyle='full',markersize=10)
	ax[1].plot(radius.in_units("au"),sim.g['part_vel'].in_units('km s^-1'),'.')
	
	ax[1].set_xlabel('R [AU]')
	ax[1].set_ylabel(r'V [$km\; s^-1$]')
	
	plt.show()
	# plt.savefig(f"Images/{sink_id}")
	plt.cla()
	plt.clf()
	plt.close()
	if check:
		for index, vel in enumerate(sim.g['part_vel']):
			particle_r = radius[index]
			e_keplerian = np.sqrt(G * c_mass / particle_r)
			if np.allclose(vel, e_keplerian, rtol=1):
				is_kepl += 1
		if is_kepl > .8*len(sim.g['part_vel']):
			print("The disk exhibits Keplerian motion.")
		else:
			print("The disk does not exhibit pure Keplerian motion.")
	
def Av_vs_density(sim,show=False,savefig=False):
	fig,ax=plt.subplots(figsize=(10,8))
	ax.plot(sim.g['rho'],sim.g['Av'],'.')
	ax.set_xlabel(f"log(rho) [{sim.g['rho'].units}]",fontproperties=fontprops)
	ax.set_ylabel("log(Av)",fontproperties=fontprops)
	ax.set_xscale('log')
	#ax.set_yscale('log')
	ax.set_ylim(1,100)
	if savefig:
		format = "png"
		dpi = 300
		path = "Images"
		plt.savefig(f"{path}/Av_vs_rho.{format}",format=format,dpi=dpi)
	if show:plt.show()
	
def print_properties(sim):
	print(f"Mass of the region is {round(sum(sim['mass']))} {sim['mass'].units}")
	print(f"Gas temperature ranges between {round(min(sim.g['temp']))} and {round(max(sim.g['temp']))} {sim.g['temp'].units}")
	print(f"Stellar masses ranges between {min(sim.bh['mass'])} and {max(sim.bh['mass'])} {sim.bh['mass'].units}")
	print(f"Number of particles inside the region: {len(sim.g)}")
	xaxis = max(sim.g['x'].in_units('pc')) - min(sim.g['x'].in_units('pc'))
	yaxis = max(sim.g['y'].in_units('pc')) - min(sim.g['y'].in_units('pc'))
	print(f"The length of the x axis is: {xaxis} pc")
	print(f"The length of the y axis is: {yaxis} pc")

def prof(data, qty="H2", units = "cm^-2", resolution = 4000, mode = 'lin', show = False, 
			 color = 'r', xmin = None, xmax = None, ymin = None, ymax = None, 
			 weighted = False, showplot=True, filename = None):
	
	width=(max(data.g['x'])-min(data.g['x']))*0.1*2

	weight = pynbody.plot.sph.image(data.g, qty = qty, units = units, 
			width = '%.3f pc'%(width), noplot = True, log = False, av_z = False, 
			resolution = resolution)
	# Replace zeros with low values
	weight[np.where(weight==0)]=1e-5
	# plt.imshow(np.log10(weight)[::-1],cmap="viridis",extent=extent, vmin=None, vmax=None, aspect='auto')
		
	flat_wght = weight.flatten()

	# Common binning for radial profiles
	pixpos = np.arange(0, resolution, 1)
	xpix,ypix = np.meshgrid(pixpos, pixpos)
	rpix = np.sqrt((xpix/resolution - 0.5)**2 + (ypix/resolution - 0.5)**2)
	rbins = np.logspace(-5,np.log10(np.max(data.g['r'])/2), 1000)
	radius = (rbins[1:] + rbins[:-1])*width/2

	H_Qnty = np.histogram(rpix.flatten(), bins = rbins, weights = flat_wght)
	Profile = (H_Qnty[0])*(width/resolution)**2/(np.pi*(rbins[1:]**2 - rbins[:-1]**2)*width**2)

	fig, ax = plt.subplots()
	ax.plot(radius, Profile)
	ax.semilogy()
	ax.set_xlabel('Radius [pc]')
	ax.set_ylabel(f"{qty} [cm**-2]")
	
	if showplot:plt.show()

	plt.cla()
	plt.clf()
	plt.close()


def main(fname):
	"""
	Main function to execute the plotting process.	
	
	Parameters:
		fname (str): The name of the data file.
	"""
	try:
		# Folder extraction
		folder = fname.split('/')[-2]

		# Sinks IDs
		sink_ids = [19989587,8662889,5935534,26041825,27780117,25183230,24803303,
				15530339,16476422,21224590,20886862,21161784,18690248]
		
		# Disk hosting sinks IDs
		disks = {"Disk 1":[8662889,19989587],
					"Disk 2":[25183230,26041825,27780117],
				 "Disk 3":[16476422,18690248,21409293],
				 "Disk 4":[24803303,26335945],
				 "Disk 5":[15530339,26549431],
				 "Disk 6":[5935534],
				 "Disk 7":[21224590],
				 "Disk 8":[16112123],
				 "Disk 9":[20886862]}
		
		width = {"Disk 1":None,
				 "Disk 2":"200 au",
				 "Disk 3":None,
				 "Disk 4":None,
				 "Disk 5":None,
				 "Disk 6":None,
				 "Disk 7":None,
				 "Disk 8":None,
				 "Disk 9":None}

		# Common units for some quantities
		units = {
			"ntot":"cm^-2",
			"rho":"g cm^-2",
			"temp":"K",
			"flux":"erg s^-1 cm^-2",
			"CO":"cm^-2",
			"H2tot":"cm^-2",
			"N2H+":"cm^-2",
			"H2D+tot":"cm^-2",
			"H2D+_ORTHO":"cm^-2",
			"NH3":"cm^-2"
		}

		# Post processed data

		snapshot_num = fname.split('/')[-1].split('_')[1]

		# Load data
		sim = load_data(fname)
		# Process data
		sim = process_data(sim)	

		# quantity = "HDO"
		# units = units[quantity]

		species, masses = species_dictionary()
		print(species)
		done_species = []

		main_sinks = [19989587, 20886862, 24803303]
		report_sinks = [19989587, 8662889, 26041825, 25183230, 24803303, 21224590, 20886862]
		# main_species = ["CO2","D2+","D2","D3O+","D","H2","H3+","HD","HE","H","N2O","C3"]
		main_species = ["CO2","N2O"]


		# specie = "H2"
		# units = "cm^-2"

		# Plot sink map used for gif
		# specie = "rho"
		# units = "g cm^-2"
		# plot_map(sim,specie,units,plot_sink=True,sink_width=500,sink_id=main_sinks[0],show=False,savefig=True,figname=f"SINK_MAP_{snapshot_num}",plot_prof=False,add_contour=False)

		# Cloud map plotting surface density
		# specie = "CO"
		# units = "cm^-2"
		# plot_map(sim,specie,units,show=True,cbar_limits=[22,16])
		# plot_map(sim,specie,units,show=True,savefig=True,figname=f"CLOUD_MAP_SURFACE_DENSITY",plot_prof=False)

		# Cloud map plotting H2O column density
		# specie = "CO_DUST"
		# units = "cm^-2"
		# plot_map(sim,specie,units,plot_sink=False,sink_width=100,sink_id=main_sinks[0],show=True,savefig=False,figname=f"",plot_prof=False)
		# # specie = "H2O"
		# units = "cm^-2"
		# plot_map(sim,specie,units,plot_sink=False,sink_width=100,sink_id=main_sinks[0],show=False,savefig=True,figname=f"CLOUD_MAP_H2O_COLUMN_DENSITY",cbar_limits=[11.0,7.0],plot_prof=False)

		# LAST USED FOR RADIAL PROFILES + MAP
		# Plot sink map along with radial profiles for 3 species
		specie = "rho"
		units = "g cm^-2"
		# plot_map(sim,specie,units,plot_sink=True,sink_width=100,sink_id=main_sinks[0],show=True,savefig=False,figname=f"a_test",plot_prof=True,add_contour=False,format="png",plot_abundances=True)
		# plot_prof(sim,prof="H2",units="cm^-2",opt='log',show=True,sink_id=main_sinks[0],sink_width=300)
		plot_prof(sim,prof="CO",units="cm^-2",opt='log',show=True,sink_id=main_sinks[0],sink_width=100,plot_abundances=True,nbins=500)
		# plot_prof(sim,prof="CO_DUST",units="cm^-2",opt='log',show=True,sink_id=main_sinks[0],sink_width=300,plot_abundances=False,nbins=500)
		

		# Plot sink CO map includding contour for H2O
		# specie = "rho"
		# units = "g cm^-2"
		# plot_map(sim,specie,units,plot_sink=True,sink_width=5000,sink_id=8662889,show=True,savefig=False,figname=f"{specie}_MAP_H2_CONT",plot_prof=False)
		
		
		
		
		
		
		# for sink in sink_ids:
		# 	print(sink)
		# 	plot_map(sim,specie,units,plot_sink=True,sink_id=sink,show=True,savefig=False,figname=f"{specie}_MAP",plot_prof=False)
		# plot_map(sim,specie,units,plot_sink=True,sink_id=main_sinks[0],show=True,savefig=False,figname=f"{specie}_MAP")
		# profile(sim,quantity=specie,units=units,show=True,savefig=False)
		# plot_map(sim,"temp",units,plot_sink=False,sink_id=main_sinks[0],show=True,savefig=False,figname=f"{specie}_MAP",cbar_limits=[24.5,23])
		# plot_map(sim,"temp",units,plot_sink=False,sink_id=main_sinks[0],show=True,savefig=False,figname=f"{specie}_MAP",cbar_limits=[24.5,23])

		# specie = "H2O"
		# plot_map(sim,specie,units,plot_sink=True,sink_id=main_sinks[0],show=False,savefig=True,figname=f"{specie}_MAP",cbar_limits=[9.5,9])


		# for sink_id in main_sinks:
		# 	for specie in main_species:
		# 		plot_map(sim,specie,units,plot_sink=True,show=False,savefig=True,sink_id=sink_id,sink_width=1000,figname=f"{sink_id}_{specie}_MAP_SINK")


		# for sink_id in main_sinks:
		# 	for specie in species:
		# 		if "META" in specie or "ANTA" in specie or "DUST" in specie or "GRAIN" in specie or "NH2D2+" in specie:
		# 			continue
		# 		else:
		# 			if "_" not in specie:
		# 				specie = specie
		# 			else:
		# 				specie = specie.split("_")[0]
		# 			if specie in done_species:
		# 				continue
		# 			plot_map(sim,specie,units,plot_sink=True,show=False,savefig=True,sink_id=sink_id,sink_width=500,add_suptitle=rf"$\mathrm{specie}$",figname=f"{sink_id}_{specie}_MAP_SINK")#,cbar_limits=[15,8])
		# 			done_species.append(specie)

		# plot_map(sim,quantity,units,plot_sink=True,savefig=True,sink_id=24803303,sink_width=1000,cbar_limits=[24,22],figname="CO_MAP_SINK")

		# for index,i in enumerate(disks):
		# 	main_sink_id = disks[i][0]
		# 	print(main_sink_id)
		# 	plot_map(sim,quantity,units,plot_sink=True,show=True,sink_id=main_sink_id,sink_width=1000)
			# if main_sink_id==24803303:
				# plot_map(sim,quantity,units,plot_sink=True,sink_id=main_sink_id,
				# 		savefig=True,show=True,ticks=False,scale=0.1,
				# 		cbar_limits=[25,19],figname=f"SINK_#{index+1}_SNAPSHOT_1137")
	except FileNotFoundError:
		print(f"Error: File not found: {fname}")
		sys.exit(1)

if __name__ == '__main__':
	if len(sys.argv) != 2:
		print("Usage: python PLOT_CLOUD.py <data_file>, please provide <data_file> path!")
		sys.exit(1)

	fname = sys.argv[1]
	main(fname)

	# directory = sys.argv[1]

	# # Iterate over files in the directory
	# for filename in os.listdir(directory):
	#     # Check if file is enumerated and its enumeration is higher than 1085
	# 	if filename.endswith(".hdf5"):
	# 		enumeration = int(filename.split("/")[-1].split("_")[1])  # Extract the enumeration
	# 		if enumeration > 1084:
	# 			fname = os.path.join(directory, filename)
	# 			main(fname)
